# org: twinmtt
# app: smartboxing
service: smartboxing

useDotenv: true

# Plugins para deploy unificado
plugins:
  - serverless-s3-sync
  - serverless-scriptable-plugin

# ConfiguraciÃ³n de plugins
custom:
  # OrÃ­genes CORS permitidos por stage
  allowedOrigins:
    dev: '*'
    staging: '*'
    prod: !Sub 'https://${CloudFrontDistribution.DomainName}'
  
  # Nivel de log por stage
  logLevel:
    dev: 'DEBUG'
    staging: 'INFO'
    prod: 'INFO'
  
  # Sync de archivos frontend a S3 (sin ACL, usar bucket policy)
  s3Sync:
    - bucketName: ${self:service}-frontend-${sls:stage}-v2
      localDir: frontend/dist
      deleteRemoved: true
      # NO usar acl (el bucket tiene ACLs bloqueadas)
      params:
        - index.html:
            CacheControl: 'no-cache, no-store, must-revalidate'
            ContentType: 'text/html'
        - "*.js":
            CacheControl: 'public, max-age=31536000, immutable'
        - "*.css":
            CacheControl: 'public, max-age=31536000, immutable'
        - "*.png":
            CacheControl: 'public, max-age=31536000, immutable'
        - "*.jpg":
            CacheControl: 'public, max-age=31536000, immutable'
        - "*.svg":
            CacheControl: 'public, max-age=31536000, immutable'
        - "*.ico":
            CacheControl: 'public, max-age=31536000, immutable'
  
  # Scripts personalizados
  scriptable:
    hooks:
      # Antes del deploy: build del frontend
      before:deploy:deploy: 
        - echo " Building frontend..."
        - npm run build:frontend
      # DespuÃ©s del deploy: generar variables de entorno
      after:deploy:finalize:
        - echo " Deploy completed!"
        - echo " Generating environment variables..."
        - node scripts/generate-frontend-env.js

provider:
  name: aws
  runtime: nodejs22.x
  region: ${env:AWS_REGION, 'us-east-1'}
  stage: ${opt:stage, 'dev'}
  
  # Deployment bucket configuration
  deploymentBucket:
    name: ${self:service}-deployment-${sls:stage}-${aws:accountId}
    serverSideEncryption: AES256
    blockPublicAccess: true
  
  # Performance: Timeout para requests complejos
  timeout: 29  # 29 segundos (API Gateway max es 30s)
  memorySize: 1024  # 1GB RAM para mejor performance
  
  # IAM Role - MÃ¡xima seguridad con VPC habilitada
  iam:
    role:
      statements:
        - Effect: Allow
          Action:
            - dynamodb:PutItem
            - dynamodb:GetItem
            - dynamodb:UpdateItem
            - dynamodb:DeleteItem
            - dynamodb:Query
            - dynamodb:Scan
            - dynamodb:BatchGetItem
            - dynamodb:BatchWriteItem
          Resource:
            - !Sub "arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${self:service}-*"
        - Effect: Allow
          Action:
            - s3:GetObject
            - s3:PutObject
            - s3:DeleteObject
          Resource:
            - !Sub "arn:aws:s3:::${self:service}-*/*"
        - Effect: Allow
          Action:
            - s3:ListBucket
          Resource:
            - !Sub "arn:aws:s3:::${self:service}-*"
        - Effect: Allow
          Action:
            - logs:CreateLogGroup
            - logs:CreateLogStream
            - logs:PutLogEvents
          Resource:
            - !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:*"
        - Effect: Allow
          Action:
            - lambda:InvokeFunction
          Resource:
            - !Sub "arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:${self:service}-*"
        # Cognito admin permissions for user management
        - Effect: Allow
          Action:
            - cognito-idp:AdminCreateUser
            - cognito-idp:AdminUpdateUserAttributes
            - cognito-idp:AdminDeleteUser
            - cognito-idp:AdminGetUser
            - cognito-idp:AdminDisableUser
            - cognito-idp:AdminEnableUser
            - cognito-idp:ListUsers
          Resource:
            - !Sub "arn:aws:cognito-idp:${AWS::Region}:${AWS::AccountId}:userpool/*"
        # DynamoDB permissions for Feature Flags (Canary)
        - Effect: Allow
          Action:
            - dynamodb:GetItem
            - dynamodb:PutItem
            - dynamodb:UpdateItem
            - dynamodb:Query
            - dynamodb:Scan
          Resource:
            - !Sub "arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${self:service}-${sls:stage}-feature-flags"
        # VPC permissions - Required for Lambda ENI management
        - Effect: Allow
          Action:
            - ec2:CreateNetworkInterface
            - ec2:DescribeNetworkInterfaces
            - ec2:DeleteNetworkInterface
            - ec2:AssignPrivateIpAddresses
            - ec2:UnassignPrivateIpAddresses
          Resource: "*"
  
  # VPC Configuration - HABILITADO para mÃ¡xima seguridad
  # Lambdas ejecutan en subnets privadas con acceso a DynamoDB/S3 via VPC Endpoints
  vpc:
    securityGroupIds:
      - !Ref LambdaSecurityGroup
    subnetIds:
      - !Ref PrivateSubnetA
      - !Ref PrivateSubnetB
  
  # API Gateway con CORS
  httpApi:
    cors: true
    authorizers:
      cognitoJwt:
        type: jwt
        identitySource: $request.header.Authorization
        issuerUrl: !Sub "https://cognito-idp.${AWS::Region}.amazonaws.com/${CognitoUserPool}"
        audience:
          - !Ref CognitoUserPoolClient

  # Variables de entorno para todas las funciones
  environment:
    # ConfiguraciÃ³n de tablas DynamoDB
    T_BOXES: ${self:service}-Boxes-${sls:stage}
    T_STAFF: ${self:service}-Staff-${sls:stage}
    T_APPOINTMENTS: ${self:service}-Appointments-${sls:stage}
    T_PATIENTS: ${self:service}-Patients-${sls:stage}
    T_CLIENT_SETTINGS: ${self:service}-ClientSettings-${sls:stage}
    T_USER_SETTINGS: ${self:service}-UserSettings-${sls:stage}
    # Multi-tenant tables
    T_TENANTS: ${self:service}-Tenants-${sls:stage}
    T_TENANT_USERS: ${self:service}-TenantUsers-${sls:stage}
    T_TENANCY_REQUESTS: ${self:service}-TenancyRequests-${sls:stage}
    # Feature Flags (Canary Deployment)
    T_FEATURE_FLAGS: ${self:service}-${sls:stage}-feature-flags
    # Cognito
    USER_POOL_ID: !Ref CognitoUserPool
    USER_POOL_CLIENT_ID: !Ref CognitoUserPoolClient
    # Entorno y versiÃ³n
    STAGE: ${sls:stage}
    APP_VERSION: ${env:APP_VERSION, '1.0.0'}
    # CORS - En producciÃ³n, restringir a CloudFront URL
    ALLOWED_ORIGINS: ${self:custom.allowedOrigins.${sls:stage}, '*'}
    # Observabilidad
    LOG_LEVEL: ${self:custom.logLevel.${sls:stage}, 'DEBUG'}
    # Chaos Engineering - Deshabilitado por defecto
    CHAOS_ENABLED: 'false'

build:
  esbuild:
    bundle: true
    minify: true
    sourcemap: true
    target: node22
    platform: node

# Incluir funciones desde backend
functions:
  # âš¡ Warm-up function - Mantiene Lambdas calientes
  warmup:
    handler: backend/src/handlers/warmup.main
    timeout: 60  # 1 minuto para invocar todas las funciones
    events:
      - schedule:
          rate: rate(5 minutes)  # Ejecutar cada 5 minutos
          enabled: true
          description: 'Keep critical Lambda functions warm'
    environment:
      WARMUP_ENABLED: 'true'
  
  # Health check
  health:
    handler: backend/src/handlers/health.main
    events:
      - httpApi:
          path: /health
          method: get

  # ========== BOXES ==========
  listBoxes:
    handler: backend/src/handlers/boxes/list.main
    events:
      - httpApi:
          path: /boxes
          method: get
          authorizer: cognitoJwt
  
  getBox:
    handler: backend/src/handlers/boxes/get.main
    events:
      - httpApi:
          path: /boxes/{id}
          method: get
          authorizer: cognitoJwt
  
  createBox:
    handler: backend/src/handlers/boxes/create.main
    events:
      - httpApi:
          path: /boxes
          method: post
          authorizer: cognitoJwt
  
  updateBox:
    handler: backend/src/handlers/boxes/update.main
    events:
      - httpApi:
          path: /boxes/{id}
          method: put
          authorizer: cognitoJwt
  
  deleteBox:
    handler: backend/src/handlers/boxes/delete.main
    events:
      - httpApi:
          path: /boxes/{id}
          method: delete
          authorizer: cognitoJwt

  # ========== STAFF ========== 
  listStaff:
    handler: backend/src/handlers/staff/list.main
    events:
      - httpApi:
          path: /staff
          method: get
          authorizer: cognitoJwt
  
  getStaffMember:
    handler: backend/src/handlers/staff/get.main
    events:
      - httpApi:
          path: /staff/{id}
          method: get
          authorizer: cognitoJwt
  
  createStaffMember:
    handler: backend/src/handlers/staff/create.main
    events:
      - httpApi:
          path: /staff
          method: post
          authorizer: cognitoJwt
  
  updateStaffMember:
    handler: backend/src/handlers/staff/update.main
    events:
      - httpApi:
          path: /staff/{id}
          method: put
          authorizer: cognitoJwt
  
  deleteStaffMember:
    handler: backend/src/handlers/staff/delete.main
    events:
      - httpApi:
          path: /staff/{id}
          method: delete
          authorizer: cognitoJwt

  # ========== APPOINTMENTS ==========
  listAppointments:
    handler: backend/src/handlers/appointments/list.main
    events:
      - httpApi:
          path: /appointments
          method: get
          authorizer: cognitoJwt
  
  getAppointment:
    handler: backend/src/handlers/appointments/get.main
    events:
      - httpApi:
          path: /appointments/{id}
          method: get
          authorizer: cognitoJwt
  
  createAppointment:
    handler: backend/src/handlers/appointments/create.main
    events:
      - httpApi:
          path: /appointments
          method: post
          authorizer: cognitoJwt
  
  updateAppointment:
    handler: backend/src/handlers/appointments/update.main
    events:
      - httpApi:
          path: /appointments/{id}
          method: put
          authorizer: cognitoJwt
  
  deleteAppointment:
    handler: backend/src/handlers/appointments/delete.main
    events:
      - httpApi:
          path: /appointments/{id}
          method: delete
          authorizer: cognitoJwt

  # ========== PATIENTS ==========
  listPatients:
    handler: backend/src/handlers/patients/list.main
    events:
      - httpApi:
          path: /patients
          method: get
          authorizer: cognitoJwt
  
  getPatient:
    handler: backend/src/handlers/patients/get.main
    events:
      - httpApi:
          path: /patients/{id}
          method: get
          authorizer: cognitoJwt
  
  createPatient:
    handler: backend/src/handlers/patients/create.main
    events:
      - httpApi:
          path: /patients
          method: post
          authorizer: cognitoJwt
  
  updatePatient:
    handler: backend/src/handlers/patients/update.main
    events:
      - httpApi:
          path: /patients/{id}
          method: put
          authorizer: cognitoJwt
  
  deletePatient:
    handler: backend/src/handlers/patients/delete.main
    events:
      - httpApi:
          path: /patients/{id}
          method: delete
          authorizer: cognitoJwt

  # ========== SEED ==========
  seedBulk:
    handler: backend/src/handlers/seed/bulk.main
    events:
      - httpApi:
          path: /seed/bulk
          method: post
          authorizer: cognitoJwt
  
  seedClear:
    handler: backend/src/handlers/seed/clear.main
    events:
      - httpApi:
          path: /seed/clear
          method: delete
          authorizer: cognitoJwt

  # ========== ğŸš€ CANARY DEPLOYMENT (Feature Flags) ==========
  # APIs para controlar despliegues graduales
  
  listFeatureFlags:
    handler: backend/src/handlers/deployment/canary.listFeatureFlags
    events:
      - httpApi:
          path: /canary/flags
          method: get
          authorizer: cognitoJwt
  
  getFeatureFlag:
    handler: backend/src/handlers/deployment/canary.getFeatureFlag
    events:
      - httpApi:
          path: /canary/flags/{flagName}
          method: get
          authorizer: cognitoJwt
  
  upsertFeatureFlag:
    handler: backend/src/handlers/deployment/canary.upsertFeatureFlag
    events:
      - httpApi:
          path: /canary/flags
          method: post
          authorizer: cognitoJwt
  
  updateRollout:
    handler: backend/src/handlers/deployment/canary.updateRollout
    events:
      - httpApi:
          path: /canary/flags/{flagName}/rollout
          method: patch
          authorizer: cognitoJwt
  
  rollbackFeature:
    handler: backend/src/handlers/deployment/canary.rollbackFeature
    events:
      - httpApi:
          path: /canary/flags/{flagName}/rollback
          method: post
          authorizer: cognitoJwt
  
  evaluateFlag:
    handler: backend/src/handlers/deployment/canary.evaluateFlag
    events:
      - httpApi:
          path: /canary/evaluate
          method: get
          # Sin auth - para que frontend pueda evaluar features
  
  deleteFeatureFlag:
    handler: backend/src/handlers/deployment/canary.deleteFeatureFlag
    events:
      - httpApi:
          path: /canary/flags/{flagName}
          method: delete
          authorizer: cognitoJwt

  # ========== SETTINGS ==========
  getClientSettings:
    handler: backend/src/handlers/settings/client-get.main
    events:
      - httpApi:
          path: /settings/client
          method: get
          authorizer: cognitoJwt
  
  updateClientSettings:
    handler: backend/src/handlers/settings/client-put.main
    events:
      - httpApi:
          path: /settings/client
          method: put
          authorizer: cognitoJwt
  
  uploadLogo:
    handler: backend/src/handlers/settings/upload-logo.main
    events:
      - httpApi:
          path: /settings/upload-logo
          method: post
          authorizer: cognitoJwt
    environment:
      SERVICE_NAME: ${self:service}
      STAGE: ${sls:stage}
  
  getUserSettings:
    handler: backend/src/handlers/settings/user-get.main
    events:
      - httpApi:
          path: /settings/user
          method: get
          authorizer: cognitoJwt
  
  updateUserSettings:
    handler: backend/src/handlers/settings/user-put.main
    events:
      - httpApi:
          path: /settings/user
          method: put
          authorizer: cognitoJwt

  # ========== ADMIN - TENANTS ==========
  listTenants:
    handler: backend/src/handlers/admin/tenants/list.main
    events:
      - httpApi:
          path: /admin/tenants
          method: get
          authorizer: cognitoJwt
  
  getTenant:
    handler: backend/src/handlers/admin/tenants/get.main
    events:
      - httpApi:
          path: /admin/tenants/{id}
          method: get
          authorizer: cognitoJwt
  
  createTenant:
    handler: backend/src/handlers/admin/tenants/create.main
    events:
      - httpApi:
          path: /admin/tenants
          method: post
          authorizer: cognitoJwt
  
  updateTenant:
    handler: backend/src/handlers/admin/tenants/update.main
    events:
      - httpApi:
          path: /admin/tenants/{id}
          method: put
          authorizer: cognitoJwt
  
  deleteTenant:
    handler: backend/src/handlers/admin/tenants/delete.main
    events:
      - httpApi:
          path: /admin/tenants/{id}
          method: delete
          authorizer: cognitoJwt
  
  # Public endpoint for registration - list available tenants
  listTenantsPublic:
    handler: backend/src/handlers/admin/tenants/list-public.main
    events:
      - httpApi:
          path: /tenants
          method: get
          # NO authorizer - public endpoint

  # ========== TENANCY REQUESTS ==========
  # User can request to create a new hospital/tenant
  createTenancyRequest:
    handler: backend/src/handlers/tenancy/request-create.main
    events:
      - httpApi:
          path: /tenancy/requests
          method: post
          authorizer: cognitoJwt
  
  # List requests (super_admin: all, user: own)
  listTenancyRequests:
    handler: backend/src/handlers/tenancy/request-list.main
    events:
      - httpApi:
          path: /tenancy/requests
          method: get
          authorizer: cognitoJwt
  
  # Super admin approves/rejects request
  reviewTenancyRequest:
    handler: backend/src/handlers/tenancy/request-review.main
    events:
      - httpApi:
          path: /tenancy/requests/{id}/review
          method: post
          authorizer: cognitoJwt
  
  # Get user's tenants (for tenant switcher)
  listUserTenancies:
    handler: backend/src/handlers/tenancy/user-tenancies.main
    events:
      - httpApi:
          path: /tenancy/my-tenants
          method: get
          authorizer: cognitoJwt
  
  # Switch active tenant
  switchTenant:
    handler: backend/src/handlers/tenancy/switch-tenant.main
    events:
      - httpApi:
          path: /tenancy/switch
          method: post
          authorizer: cognitoJwt

  # ========== ADMIN - USERS ==========
  listAdminUsers:
    handler: backend/src/handlers/admin/users/list.main
    events:
      - httpApi:
          path: /admin/users
          method: get
          authorizer: cognitoJwt
  
  getAdminUser:
    handler: backend/src/handlers/admin/users/get.main
    events:
      - httpApi:
          path: /admin/users/{id}
          method: get
          authorizer: cognitoJwt
  
  createAdminUser:
    handler: backend/src/handlers/admin/users/create.main
    events:
      - httpApi:
          path: /admin/users
          method: post
          authorizer: cognitoJwt
  
  updateAdminUser:
    handler: backend/src/handlers/admin/users/update.main
    events:
      - httpApi:
          path: /admin/users/{id}
          method: put
          authorizer: cognitoJwt
  
  deleteAdminUser:
    handler: backend/src/handlers/admin/users/delete.main
    events:
      - httpApi:
          path: /admin/users/{id}
          method: delete
          authorizer: cognitoJwt

  # ========== ANALYTICS ==========
  getDashboard:
    handler: backend/src/handlers/analytics/dashboard.main
    events:
      - httpApi:
          path: /analytics/dashboard
          method: get
          authorizer: cognitoJwt

  generateAIReport:
    handler: backend/src/handlers/analytics/ai-report.main
    timeout: 30
    environment:
      OPENAI_API_KEY: ${env:OPENAI_API_KEY, ''}
    events:
      - httpApi:
          path: /analytics/ai-report
          method: post
          authorizer: cognitoJwt

  # ========== DEPLOYMENT HOOKS (CANARY) - TEMPORALMENTE DESHABILITADO ==========
  # preTrafficHook:
  #   handler: backend/src/handlers/deployment/pre-traffic-hook.main
  #   timeout: 30
  #   environment:
  #     AWS_REGION: ${self:provider.region}
  
  # postTrafficHook:
  #   handler: backend/src/handlers/deployment/post-traffic-hook.main
  #   timeout: 30
  #   environment:
  #     AWS_REGION: ${self:provider.region}

resources:
  Resources:
    # ==================== COGNITO ====================
    CognitoUserPool:
      Type: AWS::Cognito::UserPool
      Properties:
        UserPoolName: ${self:service}-${sls:stage}
        AutoVerifiedAttributes:
          - email
        UsernameAttributes:
          - email
        Schema:
          - Name: email
            Required: true
            Mutable: false
          - Name: name
            Required: false
            Mutable: true
          - Name: tenantId
            AttributeDataType: String
            Mutable: true
          - Name: tenantName
            AttributeDataType: String
            Mutable: true
          - Name: role
            AttributeDataType: String
            Mutable: true
        Policies:
          PasswordPolicy:
            MinimumLength: 8
            RequireUppercase: true
            RequireLowercase: true
            RequireNumbers: true
            RequireSymbols: false
        MfaConfiguration: OPTIONAL
        EnabledMfas:
          - SOFTWARE_TOKEN_MFA

    CognitoUserPoolClient:
      Type: AWS::Cognito::UserPoolClient
      Properties:
        ClientName: ${self:service}-client-${sls:stage}
        UserPoolId: !Ref CognitoUserPool
        GenerateSecret: false
        ExplicitAuthFlows:
          - ALLOW_USER_PASSWORD_AUTH
          - ALLOW_REFRESH_TOKEN_AUTH
          - ALLOW_USER_SRP_AUTH
        AllowedOAuthFlows:
          - implicit
        AllowedOAuthScopes:
          - openid
          - email
          - profile
        CallbackURLs:
          - http://localhost:5173/callback
          - !Sub 'https://${CloudFrontDistribution.DomainName}/callback'
        LogoutURLs:
          - http://localhost:5173/login
          - !Sub 'https://${CloudFrontDistribution.DomainName}/login'
        SupportedIdentityProviders:
          - COGNITO
        AllowedOAuthFlowsUserPoolClient: true

    # CognitoUserPoolDomain:
    #   Type: AWS::Cognito::UserPoolDomain
    #   Properties:
    #     Domain: ${self:service}-${sls:stage}
    #     UserPoolId: !Ref CognitoUserPool

    # ==================== DYNAMODB TABLES ====================
    BoxesTable:
      Type: AWS::DynamoDB::Table
      Properties:
        TableName: ${self:provider.environment.T_BOXES}
        BillingMode: PAY_PER_REQUEST
        AttributeDefinitions:
          - AttributeName: tenantId
            AttributeType: S
          - AttributeName: id
            AttributeType: S
        KeySchema:
          - AttributeName: tenantId
            KeyType: HASH
          - AttributeName: id
            KeyType: RANGE
        PointInTimeRecoverySpecification:
          PointInTimeRecoveryEnabled: true
        Tags:
          - Key: Environment
            Value: ${sls:stage}

    StaffTable:
      Type: AWS::DynamoDB::Table
      Properties:
        TableName: ${self:provider.environment.T_STAFF}
        BillingMode: PAY_PER_REQUEST
        AttributeDefinitions:
          - AttributeName: tenantId
            AttributeType: S
          - AttributeName: id
            AttributeType: S
        KeySchema:
          - AttributeName: tenantId
            KeyType: HASH
          - AttributeName: id
            KeyType: RANGE
        PointInTimeRecoverySpecification:
          PointInTimeRecoveryEnabled: true
        Tags:
          - Key: Environment
            Value: ${sls:stage}

    AppointmentsTable:
      Type: AWS::DynamoDB::Table
      Properties:
        TableName: ${self:provider.environment.T_APPOINTMENTS}
        BillingMode: PAY_PER_REQUEST
        AttributeDefinitions:
          - AttributeName: tenantId
            AttributeType: S
          - AttributeName: id
            AttributeType: S
          - AttributeName: startAt
            AttributeType: S
        KeySchema:
          - AttributeName: tenantId
            KeyType: HASH
          - AttributeName: id
            KeyType: RANGE
        GlobalSecondaryIndexes:
          - IndexName: ByStartAt
            KeySchema:
              - AttributeName: tenantId
                KeyType: HASH
              - AttributeName: startAt
                KeyType: RANGE
            Projection:
              ProjectionType: ALL
        PointInTimeRecoverySpecification:
          PointInTimeRecoveryEnabled: true
        Tags:
          - Key: Environment
            Value: ${sls:stage}

    PatientsTable:
      Type: AWS::DynamoDB::Table
      Properties:
        TableName: ${self:provider.environment.T_PATIENTS}
        BillingMode: PAY_PER_REQUEST
        AttributeDefinitions:
          - AttributeName: tenantId
            AttributeType: S
          - AttributeName: id
            AttributeType: S
        KeySchema:
          - AttributeName: tenantId
            KeyType: HASH
          - AttributeName: id
            KeyType: RANGE
        PointInTimeRecoverySpecification:
          PointInTimeRecoveryEnabled: true
        Tags:
          - Key: Environment
            Value: ${sls:stage}

    ClientSettingsTable:
      Type: AWS::DynamoDB::Table
      Properties:
        TableName: ${self:provider.environment.T_CLIENT_SETTINGS}
        BillingMode: PAY_PER_REQUEST
        AttributeDefinitions:
          - AttributeName: tenantId
            AttributeType: S
        KeySchema:
          - AttributeName: tenantId
            KeyType: HASH
        Tags:
          - Key: Environment
            Value: ${sls:stage}

    UserSettingsTable:
      Type: AWS::DynamoDB::Table
      Properties:
        TableName: ${self:provider.environment.T_USER_SETTINGS}
        BillingMode: PAY_PER_REQUEST
        AttributeDefinitions:
          - AttributeName: tenantId
            AttributeType: S
          - AttributeName: userSub
            AttributeType: S
        KeySchema:
          - AttributeName: tenantId
            KeyType: HASH
          - AttributeName: userSub
            KeyType: RANGE
        Tags:
          - Key: Environment
            Value: ${sls:stage}

    # ==================== MULTI-TENANT TABLES ====================
    TenantsTable:
      Type: AWS::DynamoDB::Table
      Properties:
        TableName: ${self:provider.environment.T_TENANTS}
        BillingMode: PAY_PER_REQUEST
        AttributeDefinitions:
          - AttributeName: id
            AttributeType: S
          - AttributeName: slug
            AttributeType: S
        KeySchema:
          - AttributeName: id
            KeyType: HASH
        GlobalSecondaryIndexes:
          - IndexName: BySlug
            KeySchema:
              - AttributeName: slug
                KeyType: HASH
            Projection:
              ProjectionType: ALL
        PointInTimeRecoverySpecification:
          PointInTimeRecoveryEnabled: true
        Tags:
          - Key: Environment
            Value: ${sls:stage}

    # TenantUsersTable is managed outside CloudFormation
    # Table was recreated with new schema: cognitoSub (PK) + tenantId (SK)
    # GSI ByTenant: tenantId (PK) + cognitoSub (SK)
    # This allows users to belong to multiple tenants

    # ==================== TENANCY REQUESTS TABLE ====================
    TenancyRequestsTable:
      Type: AWS::DynamoDB::Table
      Properties:
        TableName: ${self:provider.environment.T_TENANCY_REQUESTS}
        BillingMode: PAY_PER_REQUEST
        AttributeDefinitions:
          - AttributeName: id
            AttributeType: S
          - AttributeName: slug
            AttributeType: S
          - AttributeName: requestedBy
            AttributeType: S
        KeySchema:
          - AttributeName: id
            KeyType: HASH
        GlobalSecondaryIndexes:
          - IndexName: BySlug
            KeySchema:
              - AttributeName: slug
                KeyType: HASH
            Projection:
              ProjectionType: ALL
          - IndexName: ByRequester
            KeySchema:
              - AttributeName: requestedBy
                KeyType: HASH
            Projection:
              ProjectionType: ALL
        Tags:
          - Key: Environment
            Value: ${sls:stage}

    # ==================== S3 PARA FRONTEND (SIN CLOUDFRONT) ====================
    # Nota: CloudFront deshabilitado debido a restricciones de permisos en AWS Academy
    # El frontend se servirÃ¡ directamente desde S3 Static Website Hosting
    
    FrontendBucket:
      Type: AWS::S3::Bucket
      Properties:
        BucketName: ${self:service}-frontend-${sls:stage}-v2
        PublicAccessBlockConfiguration:
          BlockPublicAcls: true
          BlockPublicPolicy: true
          IgnorePublicAcls: true
          RestrictPublicBuckets: true
        CorsConfiguration:
          CorsRules:
            - AllowedOrigins:
                - '*'
              AllowedMethods:
                - GET
                - HEAD
              AllowedHeaders:
                - '*'

    # CloudFront Origin Access Control (reemplaza OAI)
    CloudFrontOriginAccessControl:
      Type: AWS::CloudFront::OriginAccessControl
      Properties:
        OriginAccessControlConfig:
          Name: ${self:service}-${sls:stage}-oac
          OriginAccessControlOriginType: s3
          SigningBehavior: always
          SigningProtocol: sigv4

    # Bucket Policy para permitir acceso solo desde CloudFront
    FrontendBucketPolicy:
      Type: AWS::S3::BucketPolicy
      Properties:
        Bucket: !Ref FrontendBucket
        PolicyDocument:
          Statement:
            - Effect: Allow
              Principal:
                Service: cloudfront.amazonaws.com
              Action: s3:GetObject
              Resource: !Sub "${FrontendBucket.Arn}/*"
              Condition:
                StringEquals:
                  AWS:SourceArn: !Sub "arn:aws:cloudfront::${AWS::AccountId}:distribution/${CloudFrontDistribution}"

    # CloudFront Distribution
    CloudFrontDistribution:
      Type: AWS::CloudFront::Distribution
      DependsOn:
        - FrontendBucket
      Properties:
        DistributionConfig:
          Enabled: true
          DefaultRootObject: index.html
          Comment: ${self:service}-${sls:stage} Frontend Distribution
          PriceClass: PriceClass_100  # Solo NA y Europa (mÃ¡s barato)
          HttpVersion: http2and3
          
          Origins:
            - Id: S3Origin
              DomainName: !GetAtt FrontendBucket.RegionalDomainName
              OriginAccessControlId: !Ref CloudFrontOriginAccessControl
              S3OriginConfig: {}
          
          DefaultCacheBehavior:
            TargetOriginId: S3Origin
            ViewerProtocolPolicy: redirect-to-https
            AllowedMethods:
              - GET
              - HEAD
              - OPTIONS
            CachedMethods:
              - GET
              - HEAD
            Compress: true
            CachePolicyId: 658327ea-f89d-4fab-a63d-7e88639e58f6  # CachingOptimized
            OriginRequestPolicyId: 88a5eaf4-2fd4-4709-b370-b4c650ea3fcf  # CORS-S3Origin
            ResponseHeadersPolicyId: 67f7725c-6f97-4210-82d7-5512b31e9d03  # SecurityHeadersPolicy
          
          CustomErrorResponses:
            - ErrorCode: 403
              ResponseCode: 200
              ResponsePagePath: /index.html
              ErrorCachingMinTTL: 300
            - ErrorCode: 404
              ResponseCode: 200
              ResponsePagePath: /index.html
              ErrorCachingMinTTL: 300
          
          ViewerCertificate:
            CloudFrontDefaultCertificate: true
            MinimumProtocolVersion: TLSv1.2_2021
    
    # ==================== S3 BUCKET PARA ASSETS (LOGOS, IMÃGENES) ====================
    AssetsBucket:
      Type: AWS::S3::Bucket
      Properties:
        BucketName: ${self:service}-assets-${sls:stage}
        # Seguridad: Bloquear ACLs pÃºblicas pero permitir acceso via bucket policy
        PublicAccessBlockConfiguration:
          BlockPublicAcls: true
          BlockPublicPolicy: false  # Necesario para bucket policy pÃºblica
          IgnorePublicAcls: true
          RestrictPublicBuckets: false
        # EncriptaciÃ³n por defecto
        BucketEncryption:
          ServerSideEncryptionConfiguration:
            - ServerSideEncryptionByDefault:
                SSEAlgorithm: AES256
        # Versionado para recuperaciÃ³n de archivos
        VersioningConfiguration:
          Status: Enabled
        # Lifecycle para limpiar versiones antiguas
        LifecycleConfiguration:
          Rules:
            - Id: DeleteOldVersions
              Status: Enabled
              NoncurrentVersionExpirationInDays: 30
        CorsConfiguration:
          CorsRules:
            - AllowedOrigins:
                - '*'
              AllowedMethods:
                - GET
                - PUT
                - POST
              AllowedHeaders:
                - '*'
              MaxAge: 3600
        Tags:
          - Key: Environment
            Value: ${sls:stage}
          - Key: Security
            Value: EncryptedPublicRead
    
    # Bucket Policy para hacer pÃºblicos los logos (solo lectura)
    AssetsBucketPolicy:
      Type: AWS::S3::BucketPolicy
      Properties:
        Bucket: !Ref AssetsBucket
        PolicyDocument:
          Statement:
            # Permitir lectura pÃºblica solo de objetos
            - Sid: PublicReadGetObject
              Effect: Allow
              Principal: '*'
              Action: s3:GetObject
              Resource: !Sub "${AssetsBucket.Arn}/*"
            # Denegar acceso no encriptado (enforce HTTPS)
            - Sid: DenyInsecureTransport
              Effect: Deny
              Principal: '*'
              Action: s3:*
              Resource:
                - !Sub "${AssetsBucket.Arn}/*"
                - !GetAtt AssetsBucket.Arn
              Condition:
                Bool:
                  aws:SecureTransport: false

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    #  VPC RESOURCES - Seguridad de Red para Lambdas
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 1. VPC
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    VPC:
      Type: AWS::EC2::VPC
      Properties:
        CidrBlock: 10.0.0.0/16
        EnableDnsHostnames: true
        EnableDnsSupport: true
        Tags:
          - Key: Name
            Value: ${self:service}-vpc-${sls:stage}
          - Key: Project
            Value: SmartBoxing
          - Key: Environment
            Value: ${sls:stage}

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 2. INTERNET GATEWAY (para subnet pÃºblica)
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    InternetGateway:
      Type: AWS::EC2::InternetGateway
      Properties:
        Tags:
          - Key: Name
            Value: ${self:service}-igw-${sls:stage}

    InternetGatewayAttachment:
      Type: AWS::EC2::VPCGatewayAttachment
      Properties:
        InternetGatewayId: !Ref InternetGateway
        VpcId: !Ref VPC

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 3. SUBNETS
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # Subnet PÃšBLICA (para futuro NAT Gateway o Bastion)
    PublicSubnet:
      Type: AWS::EC2::Subnet
      Properties:
        VpcId: !Ref VPC
        AvailabilityZone: ${self:provider.region}a
        CidrBlock: 10.0.1.0/24
        MapPublicIpOnLaunch: true
        Tags:
          - Key: Name
            Value: ${self:service}-public-subnet-${sls:stage}
          - Key: Type
            Value: Public

    # Subnets PRIVADAS (para Lambdas)
    PrivateSubnetA:
      Type: AWS::EC2::Subnet
      Properties:
        VpcId: !Ref VPC
        AvailabilityZone: ${self:provider.region}a
        CidrBlock: 10.0.10.0/24
        MapPublicIpOnLaunch: false
        Tags:
          - Key: Name
            Value: ${self:service}-private-a-${sls:stage}
          - Key: Type
            Value: Private

    PrivateSubnetB:
      Type: AWS::EC2::Subnet
      Properties:
        VpcId: !Ref VPC
        AvailabilityZone: ${self:provider.region}b
        CidrBlock: 10.0.11.0/24
        MapPublicIpOnLaunch: false
        Tags:
          - Key: Name
            Value: ${self:service}-private-b-${sls:stage}
          - Key: Type
            Value: Private

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 4. ROUTE TABLES
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # Route Table PÃšBLICA
    PublicRouteTable:
      Type: AWS::EC2::RouteTable
      Properties:
        VpcId: !Ref VPC
        Tags:
          - Key: Name
            Value: ${self:service}-public-rt-${sls:stage}

    PublicRoute:
      Type: AWS::EC2::Route
      DependsOn: InternetGatewayAttachment
      Properties:
        RouteTableId: !Ref PublicRouteTable
        DestinationCidrBlock: 0.0.0.0/0
        GatewayId: !Ref InternetGateway

    PublicSubnetRouteTableAssociation:
      Type: AWS::EC2::SubnetRouteTableAssociation
      Properties:
        RouteTableId: !Ref PublicRouteTable
        SubnetId: !Ref PublicSubnet

    # Route Table PRIVADA (sin NAT Gateway - solo VPC Endpoints)
    PrivateRouteTable:
      Type: AWS::EC2::RouteTable
      Properties:
        VpcId: !Ref VPC
        Tags:
          - Key: Name
            Value: ${self:service}-private-rt-${sls:stage}
          - Key: Note
            Value: Sin NAT Gateway - Solo VPC Endpoints (DynamoDB + S3)

    PrivateSubnetARouteTableAssociation:
      Type: AWS::EC2::SubnetRouteTableAssociation
      Properties:
        RouteTableId: !Ref PrivateRouteTable
        SubnetId: !Ref PrivateSubnetA

    PrivateSubnetBRouteTableAssociation:
      Type: AWS::EC2::SubnetRouteTableAssociation
      Properties:
        RouteTableId: !Ref PrivateRouteTable
        SubnetId: !Ref PrivateSubnetB

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 5. SECURITY GROUPS
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    LambdaSecurityGroup:
      Type: AWS::EC2::SecurityGroup
      Properties:
        GroupName: ${self:service}-lambda-sg-${sls:stage}
        GroupDescription: Security Group for Lambda functions in VPC
        VpcId: !Ref VPC
        # NO Ingress rules - Lambdas no reciben conexiones directas (solo via API Gateway)
        # Egress (salida) - permitir HTTPS a VPC Endpoints y Cognito
        SecurityGroupEgress:
          # HTTPS a VPC Endpoints (DynamoDB, S3) - dentro de VPC
          - IpProtocol: tcp
            FromPort: 443
            ToPort: 443
            CidrIp: 10.0.0.0/16
            Description: HTTPS to VPC Endpoints (DynamoDB, S3)
          # HTTPS a servicios AWS (Cognito, CloudWatch) - fuera de VPC
          - IpProtocol: tcp
            FromPort: 443
            ToPort: 443
            CidrIp: 0.0.0.0/0
            Description: HTTPS to AWS Services (Cognito, CloudWatch Logs)
        Tags:
          - Key: Name
            Value: ${self:service}-lambda-sg-${sls:stage}
          - Key: Purpose
            Value: Lambda VPC Security
          - Key: Security
            Value: RestrictiveEgress

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 6. VPC ENDPOINTS (Gateway - GRATIS)
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # DynamoDB Endpoint (Gateway - Sin costo)
    DynamoDBEndpoint:
      Type: AWS::EC2::VPCEndpoint
      Properties:
        VpcId: !Ref VPC
        ServiceName: com.amazonaws.${self:provider.region}.dynamodb
        VpcEndpointType: Gateway
        RouteTableIds:
          - !Ref PrivateRouteTable
        PolicyDocument:
          Version: '2012-10-17'
          Statement:
            # Permitir acceso solo a tablas de SmartBoxing
            - Sid: AllowSmartBoxingTablesOnly
              Effect: Allow
              Principal: '*'
              Action:
                - dynamodb:PutItem
                - dynamodb:GetItem
                - dynamodb:UpdateItem
                - dynamodb:DeleteItem
                - dynamodb:Query
                - dynamodb:Scan
                - dynamodb:BatchGetItem
                - dynamodb:BatchWriteItem
              Resource:
                - !Sub "arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${self:service}-*"
              Condition:
                StringEquals:
                  aws:SourceVpc: !Ref VPC

    # S3 Endpoint (Gateway - Sin costo)
    S3Endpoint:
      Type: AWS::EC2::VPCEndpoint
      Properties:
        VpcId: !Ref VPC
        ServiceName: com.amazonaws.${self:provider.region}.s3
        VpcEndpointType: Gateway
        RouteTableIds:
          - !Ref PrivateRouteTable
        PolicyDocument:
          Version: '2012-10-17'
          Statement:
            # Permitir acceso solo a buckets de SmartBoxing
            - Sid: AllowSmartBoxingBucketsOnly
              Effect: Allow
              Principal: '*'
              Action:
                - s3:GetObject
                - s3:PutObject
                - s3:DeleteObject
                - s3:ListBucket
              Resource:
                - !Sub "arn:aws:s3:::${self:service}-*"
                - !Sub "arn:aws:s3:::${self:service}-*/*"
              Condition:
                StringEquals:
                  aws:SourceVpc: !Ref VPC
            # Denegar cualquier acciÃ³n sin HTTPS
            - Sid: DenyInsecureTransport
              Effect: Deny
              Principal: '*'
              Action: s3:*
              Resource:
                - !Sub "arn:aws:s3:::${self:service}-*"
                - !Sub "arn:aws:s3:::${self:service}-*/*"
              Condition:
                Bool:
                  aws:SecureTransport: false

    # Cognito Identity Provider Endpoint (Interface - Necesario para Lambdas en VPC)
    # NOTA: Cognito IDP no soporta us-east-1a, solo us-east-1b, 1c, 1d
    # Por eso solo usamos PrivateSubnetB (que estÃ¡ en us-east-1b)
    CognitoIdpEndpoint:
      Type: AWS::EC2::VPCEndpoint
      Properties:
        VpcId: !Ref VPC
        ServiceName: com.amazonaws.${self:provider.region}.cognito-idp
        VpcEndpointType: Interface
        SubnetIds:
          - !Ref PrivateSubnetB
        SecurityGroupIds:
          - !Ref VPCEndpointSecurityGroup
        PrivateDnsEnabled: true

    # Security Group for VPC Interface Endpoints
    VPCEndpointSecurityGroup:
      Type: AWS::EC2::SecurityGroup
      Properties:
        GroupDescription: Security group for VPC Interface Endpoints
        VpcId: !Ref VPC
        SecurityGroupIngress:
          - IpProtocol: tcp
            FromPort: 443
            ToPort: 443
            SourceSecurityGroupId: !Ref LambdaSecurityGroup
        Tags:
          - Key: Name
            Value: ${self:service}-${sls:stage}-vpc-endpoint-sg

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 7. VPC FLOW LOGS (AuditorÃ­a de trÃ¡fico)
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    VPCFlowLogsRole:
      Type: AWS::IAM::Role
      Properties:
        AssumeRolePolicyDocument:
          Version: '2012-10-17'
          Statement:
            - Effect: Allow
              Principal:
                Service: vpc-flow-logs.amazonaws.com
              Action: sts:AssumeRole
        Policies:
          - PolicyName: CloudWatchLogPolicy
            PolicyDocument:
              Version: '2012-10-17'
              Statement:
                - Effect: Allow
                  Action:
                    - logs:CreateLogGroup
                    - logs:CreateLogStream
                    - logs:PutLogEvents
                    - logs:DescribeLogGroups
                    - logs:DescribeLogStreams
                  Resource: '*'

    VPCFlowLogsGroup:
      Type: AWS::Logs::LogGroup
      Properties:
        LogGroupName: /aws/vpc/${self:service}-${sls:stage}
        RetentionInDays: 30

    VPCFlowLog:
      Type: AWS::EC2::FlowLog
      Properties:
        ResourceType: VPC
        ResourceId: !Ref VPC
        TrafficType: ALL
        LogDestinationType: cloud-watch-logs
        LogGroupName: !Ref VPCFlowLogsGroup
        DeliverLogsPermissionArn: !GetAtt VPCFlowLogsRole.Arn
        Tags:
          - Key: Name
            Value: ${self:service}-flow-logs-${sls:stage}

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 8. NETWORK ACLs (Capa adicional de seguridad)
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    PrivateNetworkAcl:
      Type: AWS::EC2::NetworkAcl
      Properties:
        VpcId: !Ref VPC
        Tags:
          - Key: Name
            Value: ${self:service}-private-nacl-${sls:stage}

    # Inbound Rules
    PrivateNetworkAclInboundHTTPS:
      Type: AWS::EC2::NetworkAclEntry
      Properties:
        NetworkAclId: !Ref PrivateNetworkAcl
        RuleNumber: 100
        Protocol: 6  # TCP
        RuleAction: allow
        CidrBlock: 10.0.0.0/16
        PortRange:
          From: 443
          To: 443

    PrivateNetworkAclInboundEphemeral:
      Type: AWS::EC2::NetworkAclEntry
      Properties:
        NetworkAclId: !Ref PrivateNetworkAcl
        RuleNumber: 110
        Protocol: 6  # TCP
        RuleAction: allow
        CidrBlock: 0.0.0.0/0
        PortRange:
          From: 1024
          To: 65535

    # Outbound Rules
    PrivateNetworkAclOutboundHTTPS:
      Type: AWS::EC2::NetworkAclEntry
      Properties:
        NetworkAclId: !Ref PrivateNetworkAcl
        RuleNumber: 100
        Protocol: 6  # TCP
        RuleAction: allow
        Egress: true
        CidrBlock: 0.0.0.0/0
        PortRange:
          From: 443
          To: 443

    PrivateNetworkAclOutboundEphemeral:
      Type: AWS::EC2::NetworkAclEntry
      Properties:
        NetworkAclId: !Ref PrivateNetworkAcl
        RuleNumber: 110
        Protocol: 6  # TCP
        RuleAction: allow
        Egress: true
        CidrBlock: 0.0.0.0/0
        PortRange:
          From: 1024
          To: 65535

    # Asociar NACL a subnets privadas
    PrivateSubnetANetworkAclAssociation:
      Type: AWS::EC2::SubnetNetworkAclAssociation
      Properties:
        SubnetId: !Ref PrivateSubnetA
        NetworkAclId: !Ref PrivateNetworkAcl

    PrivateSubnetBNetworkAclAssociation:
      Type: AWS::EC2::SubnetNetworkAclAssociation
      Properties:
        SubnetId: !Ref PrivateSubnetB
        NetworkAclId: !Ref PrivateNetworkAcl

    # ==================== CANARY DEPLOYMENT (FEATURE FLAGS) ====================
    # ImplementaciÃ³n de Canary usando Feature Flags en DynamoDB
    # Esta estrategia permite despliegues graduales controlando el % de usuarios
    # que ven nuevas funcionalidades
    
    # Tabla para Feature Flags y Canary configuration
    FeatureFlagsTable:
      Type: AWS::DynamoDB::Table
      Properties:
        TableName: ${self:service}-${sls:stage}-feature-flags
        BillingMode: PAY_PER_REQUEST
        AttributeDefinitions:
          - AttributeName: flagName
            AttributeType: S
        KeySchema:
          - AttributeName: flagName
            KeyType: HASH
        Tags:
          - Key: Environment
            Value: ${sls:stage}
          - Key: Purpose
            Value: CanaryDeployment

    # SNS Topic para alertas de deployment
    DeploymentAlertTopic:
      Type: AWS::SNS::Topic
      Properties:
        TopicName: ${self:service}-${sls:stage}-deployment-alerts
        DisplayName: SmartBoxing Deployment Alerts

    # CloudWatch Alarm: Error Rate > 5 errores en 2 minutos
    ApiErrorAlarm:
      Type: AWS::CloudWatch::Alarm
      Properties:
        AlarmName: ${self:service}-${sls:stage}-api-error-rate
        AlarmDescription: "API Error rate too high (>5 errors in 2 min)"
        MetricName: Errors
        Namespace: AWS/Lambda
        Statistic: Sum
        Period: 60
        EvaluationPeriods: 2
        Threshold: 5
        ComparisonOperator: GreaterThanThreshold
        TreatMissingData: notBreaching
        AlarmActions:
          - !Ref DeploymentAlertTopic
        Dimensions:
          - Name: FunctionName
            Value: ${self:service}-${sls:stage}-health

    # CloudWatch Alarm: Latencia p99 > 3000ms
    ApiLatencyAlarm:
      Type: AWS::CloudWatch::Alarm
      Properties:
        AlarmName: ${self:service}-${sls:stage}-api-latency
        AlarmDescription: "API Latency too high (p99 > 3000ms)"
        MetricName: Duration
        Namespace: AWS/Lambda
        ExtendedStatistic: p99
        Period: 60
        EvaluationPeriods: 2
        Threshold: 3000
        ComparisonOperator: GreaterThanThreshold
        TreatMissingData: notBreaching
        AlarmActions:
          - !Ref DeploymentAlertTopic
        Dimensions:
          - Name: FunctionName
            Value: ${self:service}-${sls:stage}-health

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # OUTPUTS
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Outputs:
    # API
    ApiUrl:
      Description: URL del API Gateway
      Value: !Sub "https://${HttpApi}.execute-api.${AWS::Region}.amazonaws.com"
      Export:
        Name: ${self:service}-${sls:stage}-ApiUrl

    # Cognito
    UserPoolId:
      Description: ID del Cognito User Pool
      Value: !Ref CognitoUserPool
      Export:
        Name: ${self:service}-${sls:stage}-UserPoolId

    UserPoolClientId:
      Description: ID del Cognito User Pool Client
      Value: !Ref CognitoUserPoolClient
      Export:
        Name: ${self:service}-${sls:stage}-UserPoolClientId

    # CognitoDomain:
    #   Description: Dominio de Cognito para login
    #   Value: !Sub "https://${CognitoUserPoolDomain}.auth.${AWS::Region}.amazoncognito.com"
    #   Export:
    #     Name: ${self:service}-${sls:stage}-CognitoDomain

    # Frontend
    FrontendBucketName:
      Description: Nombre del bucket S3 para frontend
      Value: !Ref FrontendBucket
      Export:
        Name: ${self:service}-${sls:stage}-FrontendBucket

    FrontendUrl:
      Description: URL del frontend (S3 Static Website - Deprecated, usar CloudFrontUrl)
      Value: !Sub "http://${FrontendBucket}.s3-website-${AWS::Region}.amazonaws.com"
      Export:
        Name: ${self:service}-${sls:stage}-FrontendUrl

    CloudFrontUrl:
      Description: URL del frontend (CloudFront HTTPS) - URL PRINCIPAL
      Value: !Sub "https://${CloudFrontDistribution.DomainName}"
      Export:
        Name: ${self:service}-${sls:stage}-CloudFrontUrl
    
    CloudFrontDistributionId:
      Description: ID de la distribucion CloudFront
      Value: !Ref CloudFrontDistribution
      Export:
        Name: ${self:service}-${sls:stage}-CloudFrontDistributionId

    # DynamoDB Tables
    BoxesTableName:
      Description: Nombre de la tabla Boxes
      Value: !Ref BoxesTable

    StaffTableName:
      Description: Nombre de la tabla Staff
      Value: !Ref StaffTable

    AppointmentsTableName:
      Description: Nombre de la tabla Appointments
      Value: !Ref AppointmentsTable

    PatientsTableName:
      Description: Nombre de la tabla Patients
      Value: !Ref PatientsTable

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ğŸ”’ VPC Outputs
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    VPCId:
      Description: VPC ID
      Value: !Ref VPC
      Export:
        Name: ${self:service}-VPCId-${sls:stage}

    VPCCidr:
      Description: VPC CIDR Block
      Value: 10.0.0.0/16
      Export:
        Name: ${self:service}-VPCCidr-${sls:stage}

    PublicSubnetId:
      Description: Public Subnet ID
      Value: !Ref PublicSubnet
      Export:
        Name: ${self:service}-PublicSubnet-${sls:stage}

    PrivateSubnetAId:
      Description: Private Subnet A ID (AZ-a)
      Value: !Ref PrivateSubnetA
      Export:
        Name: ${self:service}-PrivateSubnetA-${sls:stage}

    PrivateSubnetBId:
      Description: Private Subnet B ID (AZ-b)
      Value: !Ref PrivateSubnetB
      Export:
        Name: ${self:service}-PrivateSubnetB-${sls:stage}

    LambdaSecurityGroupId:
      Description: Lambda Security Group ID
      Value: !Ref LambdaSecurityGroup
      Export:
        Name: ${self:service}-LambdaSG-${sls:stage}

    DynamoDBEndpointId:
      Description: DynamoDB VPC Endpoint ID
      Value: !Ref DynamoDBEndpoint
      Export:
        Name: ${self:service}-DynamoDBEndpoint-${sls:stage}

    S3EndpointId:
      Description: S3 VPC Endpoint ID
      Value: !Ref S3Endpoint
      Export:
        Name: ${self:service}-S3Endpoint-${sls:stage}

    VPCFlowLogsGroupName:
      Description: VPC Flow Logs CloudWatch Log Group
      Value: !Ref VPCFlowLogsGroup
      Export:
        Name: ${self:service}-FlowLogs-${sls:stage}

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ğŸš€ Canary Deployment & Feature Flags Outputs
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    FeatureFlagsTableName:
      Description: DynamoDB Table for Feature Flags (Canary Control)
      Value: !Ref FeatureFlagsTable
      Export:
        Name: ${self:service}-${sls:stage}-FeatureFlags

    DeploymentAlertTopicArn:
      Description: SNS Topic ARN for Deployment Alerts
      Value: !Ref DeploymentAlertTopic
      Export:
        Name: ${self:service}-${sls:stage}-DeploymentAlerts

